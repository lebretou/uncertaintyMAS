/**
 * Python Execution Service
 *
 * Executes Python code generated by agents and returns the results.
 *
 * IMPORTANT: This is a mock implementation for development.
 * In production, you would:
 * 1. Use a backend API to execute Python in a sandboxed environment
 * 2. Use Pyodide (Python in WebAssembly) for browser execution
 * 3. Use a serverless function (AWS Lambda, etc.)
 */

import { getCSVData } from './dataStorage';

export interface PythonExecutionResult {
  success: boolean;
  output?: string;
  error?: string;
  executionTime: number;
}

/**
 * Execute Python code
 *
 * @param pythonCode - The Python code to execute
 * @param filePath - Optional file path referenced in the code
 * @returns Execution result with output or error
 */
export async function executePython(
  pythonCode: string,
  filePath?: string
): Promise<PythonExecutionResult> {
  const startTime = Date.now();

  try {
    console.log('Executing Python code:', {
      codeLength: pythonCode.length,
      filePath,
    });

    // MOCK IMPLEMENTATION: In production, replace this with actual Python execution
    // For now, we'll simulate execution with mock data
    const result = await mockPythonExecution(pythonCode, filePath);

    const executionTime = Date.now() - startTime;

    console.log('Python execution completed:', {
      success: result.success,
      outputLength: result.output?.length,
      executionTime,
    });

    return {
      ...result,
      executionTime,
    };
  } catch (error) {
    const executionTime = Date.now() - startTime;

    console.error('Python execution failed:', error);

    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
      executionTime,
    };
  }
}

/**
 * Mock Python execution for development
 *
 * Replace this with actual Python execution in production
 */
async function mockPythonExecution(
  pythonCode: string,
  filePath?: string
): Promise<Omit<PythonExecutionResult, 'executionTime'>> {
  // Simulate some processing time
  await new Promise(resolve => setTimeout(resolve, 500));

  // If filePath is provided, try to get the actual CSV data
  let csvData: string | null = null;
  if (filePath) {
    csvData = getCSVData(filePath);
  }

  // Check what kind of code this is based on imports and content
  const isIngestCode = pythonCode.includes('pd.read_csv') && !pythonCode.includes('fillna');
  const isAnalyticsCode = pythonCode.includes('LinearRegression') || pythonCode.includes('OLS');
  const isCleaningCode = pythonCode.includes('dropna') || pythonCode.includes('fillna') || pythonCode.includes('drop_duplicates');

  if (isIngestCode && csvData) {
    // Parse the CSV to generate real schema information
    return mockIngestExecution(csvData, filePath!);
  } else if (isAnalyticsCode) {
    // Mock analytics results
    return mockAnalyticsExecution();
  } else if (isCleaningCode && filePath) {
    // Mock cleaning results
    return mockCleaningExecution(filePath, pythonCode);
  }

  // Default fallback
  return {
    success: true,
    output: JSON.stringify({
      message: 'Mock execution completed',
      note: 'Replace with actual Python execution in production',
    }),
  };
}

/**
 * Mock ingest execution - parses CSV and returns real schema
 */
function mockIngestExecution(csvData: string, filePath: string): Omit<PythonExecutionResult, 'executionTime'> {
  try {
    // Parse CSV
    const lines = csvData.trim().split('\n');
    const headers = lines[0].split(',').map(h => h.trim());
    const dataRows = lines.slice(1);

    // Infer types
    const types: Record<string, string> = {};
    const sampleValues: Record<string, any[]> = {};

    headers.forEach((header, colIndex) => {
      const values = dataRows
        .map(row => row.split(',')[colIndex]?.trim())
        .filter(v => v && v !== '');

      sampleValues[header] = values.slice(0, 5);

      // Simple type inference
      const numericValues = values.filter(v => !isNaN(Number(v)));
      if (numericValues.length === values.length && values.length > 0) {
        types[header] = 'numeric';
      } else {
        types[header] = 'categorical';
      }
    });

    // Check for quality issues
    const qualityIssues = [];
    headers.forEach((header, colIndex) => {
      const values = dataRows.map(row => row.split(',')[colIndex]?.trim());
      const missingCount = values.filter(v => !v || v === '').length;

      if (missingCount > 0) {
        qualityIssues.push({
          type: 'missing',
          column: header,
          count: missingCount,
        });
      }
    });

    // Check for duplicates
    const uniqueRows = new Set(dataRows);
    const duplicateCount = dataRows.length - uniqueRows.size;
    if (duplicateCount > 0) {
      qualityIssues.push({
        type: 'duplicates',
        count: duplicateCount,
      });
    }

    // Build sample rows string
    const sampleRows = [
      headers.join(', '),
      ...dataRows.slice(0, 5).map(row => row),
    ].join('\n');

    const result = {
      dataRef: filePath,
      schema: {
        columns: headers,
        types,
        rowCount: dataRows.length,
      },
      qualityIssues,
      sampleRows,
    };

    return {
      success: true,
      output: JSON.stringify(result),
    };
  } catch (error) {
    return {
      success: false,
      error: `Failed to parse CSV: ${error instanceof Error ? error.message : String(error)}`,
    };
  }
}

/**
 * Mock cleaning execution
 */
function mockCleaningExecution(sourceFilePath: string, pythonCode?: string): Omit<PythonExecutionResult, 'executionTime'> {
  // Get the actual CSV data to simulate real cleaning
  const csvData = getCSVData(sourceFilePath);
  if (!csvData) {
    return {
      success: false,
      error: `Cannot find data file: ${sourceFilePath}`,
    };
  }

  // Parse CSV to get real schema
  const lines = csvData.trim().split('\n');
  const headers = lines[0].split(',').map(h => h.trim());
  const dataRows = lines.slice(1);

  // Extract user prompt from Python code if present
  let userPrompt = 'Analyze the data';
  if (pythonCode) {
    const promptMatch = pythonCode.match(/"userPrompt":\s*"([^"]*)"/);
    if (promptMatch) {
      userPrompt = promptMatch[1].replace('USER_PROMPT_PLACEHOLDER', userPrompt);
    }
  }

  // Simulate cleaning transformations
  const transformationLog = [];

  // Check for missing values
  let missingCount = 0;
  headers.forEach((header, colIndex) => {
    const values = dataRows.map(row => row.split(',')[colIndex]?.trim());
    const missing = values.filter(v => !v || v === '').length;
    if (missing > 0) {
      missingCount += missing;
      transformationLog.push(`Imputed ${missing} missing values in '${header}'`);
    }
  });

  // Check for duplicates
  const uniqueRows = new Set(dataRows);
  const duplicateCount = dataRows.length - uniqueRows.size;
  if (duplicateCount > 0) {
    transformationLog.push(`Removed ${duplicateCount} duplicate rows`);
  }

  const cleanedRowCount = uniqueRows.size;
  const cleanedFilePath = sourceFilePath.replace('.csv', '_cleaned.parquet');

  // Infer types for cleaned data
  const types: Record<string, string> = {};
  headers.forEach((header, colIndex) => {
    const values = Array.from(uniqueRows)
      .map(row => row.split(',')[colIndex]?.trim())
      .filter(v => v && v !== '');

    const numericValues = values.filter(v => !isNaN(Number(v)));
    types[header] = numericValues.length === values.length ? 'float64' : 'object';
  });

  const result = {
    cleaningStrategy: {
      missingValues: 'Mean imputation for numeric, mode for categorical',
      outliers: 'No outlier removal applied',
      duplicates: 'Removed all duplicate rows',
    },
    transformationLog,
    cleanedDataRef: cleanedFilePath,
    contextPacket: {
      dataRef: cleanedFilePath,
      schema: {
        columns: headers,
        types,
        rowCount: cleanedRowCount,
      },
      userPrompt,
    },
  };

  return {
    success: true,
    output: JSON.stringify(result),
  };
}

/**
 * Mock analytics execution - returns regression results
 */
function mockAnalyticsExecution(): Omit<PythonExecutionResult, 'executionTime'> {
  const result = {
    analysisType: 'linear_regression',
    coefficients: [50000, 5000], // intercept, slope
    r_squared: 0.72,
    p_values: [0.001, 0.0001],
    residuals_std: 8500,
    predictions: [55000, 60000, 65000, 70000, 75000],
    interpretation: 'Strong positive relationship detected. For each unit increase in X, Y increases by approximately 5000.',
  };

  return {
    success: true,
    output: JSON.stringify(result),
  };
}

/**
 * Parse Python code execution output as JSON
 */
export function parseExecutionOutput(output: string): any {
  try {
    return JSON.parse(output);
  } catch (error) {
    console.warn('Failed to parse execution output as JSON, returning as string');
    return { output };
  }
}
